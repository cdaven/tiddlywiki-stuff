{
    "created": "20220513060030443",
    "tags": "",
    "title": "$:/plugins/cdaven/markdown-export",
    "modified": "20220530121846383",
    "name": "Markdown Export",
    "plugin-type": "plugin",
    "description": "Markdown export of tiddlers",
    "version": "0.1.7",
    "list": "readme license",
    "author": "cdaven",
    "dependents": "",
    "type": "application/json",
    "text": "{\"tiddlers\":{\"$:/plugins/cdaven/markdown-export/license\":{\"title\":\"$:/plugins/cdaven/markdown-export/license\",\"created\":\"20220513163358248\",\"modified\":\"20220513163418690\",\"tags\":\"\",\"text\":\"Copyright 2022 Christian Dav√©n\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \\\"Software\\\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\"},\"$:/plugins/cdaven/markdown-export/markdown-export.js\":{\"title\":\"$:/plugins/cdaven/markdown-export/markdown-export.js\",\"text\":\"(function (factory) {\\r\\n    if (typeof module === \\\"object\\\" && typeof module.exports === \\\"object\\\") {\\r\\n        var v = factory(require, exports);\\r\\n        if (v !== undefined) module.exports = v;\\r\\n    }\\r\\n    else if (typeof define === \\\"function\\\" && define.amd) {\\r\\n        define([\\\"require\\\", \\\"exports\\\"], factory);\\r\\n    }\\r\\n})(function (require, exports) {\\r\\n    \\\"use strict\\\";\\r\\n    Object.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n    exports.run = exports.params = exports.name = void 0;\\r\\n    exports.name = \\\"markdown-export\\\";\\r\\n    const defaultFilter = \\\"\\\";\\r\\n    const defaultFormat = \\\"markdown\\\";\\r\\n    exports.params = [\\r\\n        {\\r\\n            name: \\\"filter\\\",\\r\\n            default: defaultFilter\\r\\n        },\\r\\n        {\\r\\n            name: \\\"format\\\",\\r\\n            default: defaultFormat\\r\\n        },\\r\\n    ];\\r\\n    function isTextNode(node) {\\r\\n        return node.nodeType === Node.TEXT_NODE;\\r\\n    }\\r\\n    function isDomNode(node) {\\r\\n        return node.nodeType === Node.ELEMENT_NODE;\\r\\n    }\\r\\n    class MarkdownRenderer {\\r\\n        constructor(tw) {\\r\\n            this.tw = tw;\\r\\n            this.rules = this.getRules();\\r\\n        }\\r\\n        renderTiddler(title) {\\r\\n            if (this.rules == null) {\\r\\n                console.warn(\\\"Cannot render tiddler without rules\\\");\\r\\n                return null;\\r\\n            }\\r\\n            const widgetNode = this.tw.wiki.makeTranscludeWidget(title, widgetOptions);\\r\\n            const container = this.tw.fakeDocument.createElement(\\\"div\\\");\\r\\n            widgetNode.render(container, null);\\r\\n            const nodes = container.children[0].children;\\r\\n            const tiddler = this.tw.wiki.getTiddler(title);\\r\\n            if (tiddler == null) {\\r\\n                console.warn(\\\"Found no such tiddler\\\", title);\\r\\n                return null;\\r\\n            }\\r\\n            this.tiddlerFields = Object.assign({}, tiddler.fields);\\r\\n            let markup = \\\"\\\";\\r\\n            for (const node of nodes) {\\r\\n                const nodeMarkup = this.renderNode(node);\\r\\n                if (nodeMarkup != null) {\\r\\n                    markup += nodeMarkup;\\r\\n                }\\r\\n            }\\r\\n            const metaNode = {\\r\\n                tag: \\\"meta\\\",\\r\\n                nodeType: Node.ELEMENT_NODE,\\r\\n                attributes: this.tiddlerFields,\\r\\n                children: []\\r\\n            };\\r\\n            return this.renderNode(metaNode) + markup;\\r\\n        }\\r\\n        getRules() {\\r\\n            const katexStart = '<annotation encoding=\\\"application/x-tex\\\">';\\r\\n            let rules = {\\r\\n                \\\"meta\\\": (node) => {\\r\\n                    const fields = node.attributes;\\r\\n                    console.log(\\\"tw fields\\\", fields);\\r\\n                    let frontMatter = [];\\r\\n                    if (fields.title) {\\r\\n                        frontMatter.push(`title: '${fields.title}'`);\\r\\n                    }\\r\\n                    if (fields.author) {\\r\\n                        frontMatter.push(`author: '${fields.author}'`);\\r\\n                    }\\r\\n                    if (fields.modified) {\\r\\n                        frontMatter.push(`date: '${fields.modified.toISOString()}'`);\\r\\n                    }\\r\\n                    if (fields.description) {\\r\\n                        frontMatter.push(`abstract: '${fields.description}'`);\\r\\n                    }\\r\\n                    if (fields.tags) {\\r\\n                        frontMatter.push(`tags: ['${fields.tags.join(',')}']`);\\r\\n                    }\\r\\n                    return `---\\\\n${frontMatter.join(\\\"\\\\n\\\")}\\\\n---\\\\n\\\\n# ${fields.title}\\\\n\\\\n`;\\r\\n                },\\r\\n                \\\"p\\\": (_, im) => `${im.trim()}\\\\n\\\\n`,\\r\\n                \\\"em\\\": (_, im) => `*${im}*`,\\r\\n                \\\"strong\\\": (_, im) => `**${im}**`,\\r\\n                \\\"u\\\": (_, im) => `<u>${im}</u>`,\\r\\n                \\\"strike\\\": (_, im) => `~~${im}~~`,\\r\\n                \\\"br\\\": (node) => {\\r\\n                    const nextNode = this.getNextNode(node);\\r\\n                    if (nextNode == null || (isTextNode(nextNode) && nextNode.textContent === \\\"\\\\n\\\")) {\\r\\n                        return \\\"\\\\n\\\";\\r\\n                    }\\r\\n                    else {\\r\\n                        return \\\"\\\\\\\\\\\\n\\\";\\r\\n                    }\\r\\n                },\\r\\n                \\\"hr\\\": () => `---\\\\n\\\\n`,\\r\\n                \\\"label\\\": (_, im) => im,\\r\\n                \\\"mark\\\": (_, im) => `<mark>${im}</mark>`,\\r\\n                \\\"span\\\": (node, im) => {\\r\\n                    if (node.rawHTML && node.rawHTML.indexOf(katexStart) !== -1) {\\r\\n                        let mathEq = node.rawHTML.substring(node.rawHTML.indexOf(katexStart) + katexStart.length);\\r\\n                        mathEq = mathEq.substring(0, mathEq.indexOf('</annotation>'));\\r\\n                        if (mathEq.startsWith(\\\"\\\\n\\\") && mathEq.endsWith(\\\"\\\\n\\\")) {\\r\\n                            return `$$${mathEq}$$\\\\n\\\\n`;\\r\\n                        }\\r\\n                        else {\\r\\n                            return `$${mathEq}$`;\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        return im;\\r\\n                    }\\r\\n                },\\r\\n                \\\"sub\\\": (_, im) => `~${im.replace(/ /g, \\\"\\\\\\\\ \\\")}~`,\\r\\n                \\\"sup\\\": (_, im) => `^${im.replace(/ /g, \\\"\\\\\\\\ \\\")}^`,\\r\\n                \\\"h1\\\": (_, im) => `# ${im}\\\\n\\\\n`,\\r\\n                \\\"h2\\\": (_, im) => `## ${im}\\\\n\\\\n`,\\r\\n                \\\"h3\\\": (_, im) => `### ${im}\\\\n\\\\n`,\\r\\n                \\\"h4\\\": (_, im) => `#### ${im}\\\\n\\\\n`,\\r\\n                \\\"dl\\\": (_, im) => `${im.trim()}\\\\n\\\\n`,\\r\\n                \\\"dt\\\": (_, im) => `${im}\\\\n`,\\r\\n                \\\"dd\\\": (_, im) => ` ~ ${im}\\\\n\\\\n`,\\r\\n                \\\"pre\\\": (node, im) => {\\r\\n                    if (node.children.every(child => isDomNode(child) && child.tag === \\\"code\\\")) {\\r\\n                        return im;\\r\\n                    }\\r\\n                    else {\\r\\n                        return `\\\\`\\\\`\\\\`\\\\n${im.trim()}\\\\n\\\\`\\\\`\\\\`\\\\n\\\\n`;\\r\\n                    }\\r\\n                },\\r\\n                \\\"code\\\": (node, im) => {\\r\\n                    var _a, _b, _c;\\r\\n                    if (((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.tag) === \\\"pre\\\") {\\r\\n                        let classRx = (_c = (_b = node.attributes) === null || _b === void 0 ? void 0 : _b.class) === null || _c === void 0 ? void 0 : _c.match(/^(.+) hljs$/);\\r\\n                        if (classRx) {\\r\\n                            const lang = classRx[1];\\r\\n                            return `\\\\`\\\\`\\\\`${lang}\\\\n${im}\\\\n\\\\`\\\\`\\\\`\\\\n\\\\n`;\\r\\n                        }\\r\\n                        else {\\r\\n                            return `\\\\`\\\\`\\\\`\\\\n${im}\\\\n\\\\`\\\\`\\\\`\\\\n\\\\n`;\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        return `\\\\`${im}\\\\``;\\r\\n                    }\\r\\n                },\\r\\n                \\\"blockquote\\\": (_, im) => {\\r\\n                    return `> ${im.trim().replace(/\\\\n/g, \\\"\\\\n> \\\")}\\\\n\\\\n`;\\r\\n                },\\r\\n                \\\"cite\\\": (_, im) => {\\r\\n                    return `<cite>${im}</cite>`;\\r\\n                },\\r\\n                \\\"ul\\\": (node, im) => {\\r\\n                    if (node.parentNode && node.parentNode.tag === \\\"li\\\") {\\r\\n                        return `\\\\n${im}`;\\r\\n                    }\\r\\n                    else {\\r\\n                        return `${im.trim()}\\\\n\\\\n`;\\r\\n                    }\\r\\n                },\\r\\n                \\\"li\\\": (node, im) => {\\r\\n                    let curNode = node.parentNode;\\r\\n                    if (curNode == null) {\\r\\n                        console.error(\\\"Found <li> without parent\\\");\\r\\n                        return null;\\r\\n                    }\\r\\n                    const listType = curNode.tag === \\\"ul\\\" ? \\\"*\\\" : \\\"1.\\\";\\r\\n                    const listTags = [\\\"ul\\\", \\\"ol\\\", \\\"li\\\"];\\r\\n                    let depth = -1;\\r\\n                    while (curNode && listTags.indexOf(curNode.tag) !== -1) {\\r\\n                        if (curNode.tag !== \\\"li\\\") {\\r\\n                            depth++;\\r\\n                        }\\r\\n                        curNode = curNode.parentNode;\\r\\n                    }\\r\\n                    return `${\\\"    \\\".repeat(depth)}${listType} ${im}\\\\n`;\\r\\n                },\\r\\n                \\\"input\\\": (node) => {\\r\\n                    var _a, _b;\\r\\n                    console.log(\\\"input\\\", node);\\r\\n                    if (((_a = node.attributes) === null || _a === void 0 ? void 0 : _a.type) === \\\"checkbox\\\") {\\r\\n                        if ((_b = node.attributes) === null || _b === void 0 ? void 0 : _b.checked) {\\r\\n                            return \\\"[x]\\\";\\r\\n                        }\\r\\n                        else {\\r\\n                            return \\\"[ ]\\\";\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        console.warn(\\\"Unsupported input node type\\\", node);\\r\\n                        return null;\\r\\n                    }\\r\\n                },\\r\\n                \\\"a\\\": (node, im) => {\\r\\n                    var _a;\\r\\n                    const href = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.href;\\r\\n                    if (href == null || (href === null || href === void 0 ? void 0 : href.startsWith(\\\"#\\\"))) {\\r\\n                        return im;\\r\\n                    }\\r\\n                    else if (im && im != href) {\\r\\n                        return `[${im}](${href})`;\\r\\n                    }\\r\\n                    else {\\r\\n                        return `<${href}>`;\\r\\n                    }\\r\\n                },\\r\\n                \\\"img\\\": (node) => {\\r\\n                    var _a, _b;\\r\\n                    let caption = ((_a = node.attributes) === null || _a === void 0 ? void 0 : _a.title) || \\\"\\\";\\r\\n                    let src = ((_b = node.attributes) === null || _b === void 0 ? void 0 : _b.src) || \\\"\\\";\\r\\n                    const svgPrefix = \\\"data:image/svg+xml,\\\";\\r\\n                    if (src.startsWith(svgPrefix)) {\\r\\n                        src = svgPrefix.replace(\\\"svg+xml,\\\", \\\"svg+xml;base64,\\\") +\\r\\n                            btoa(decodeURIComponent(src.substring(svgPrefix.length)));\\r\\n                    }\\r\\n                    return `![${caption}](${src})`;\\r\\n                },\\r\\n                \\\"table\\\": (node) => {\\r\\n                    let tbody = null;\\r\\n                    for (const child of node.children) {\\r\\n                        if (isDomNode(child) && child.tag === \\\"tbody\\\") {\\r\\n                            tbody = child;\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n                    if (tbody == null) {\\r\\n                        return null;\\r\\n                    }\\r\\n                    let justifyLeft = (s, w) => {\\r\\n                        const sLen = (s === null || s === void 0 ? void 0 : s.length) || 0;\\r\\n                        return s + ' '.repeat(w - sLen);\\r\\n                    };\\r\\n                    let justifyRight = (s, w) => {\\r\\n                        const sLen = (s === null || s === void 0 ? void 0 : s.length) || 0;\\r\\n                        return ' '.repeat(w - sLen) + s;\\r\\n                    };\\r\\n                    let center = (s, w) => {\\r\\n                        const sLen = (s === null || s === void 0 ? void 0 : s.length) || 0;\\r\\n                        const spacesLeft = Math.ceil((w - sLen) / 2);\\r\\n                        const spacesRight = w - sLen - spacesLeft;\\r\\n                        return ' '.repeat(spacesLeft) + s + ' '.repeat(spacesRight);\\r\\n                    };\\r\\n                    let grid = [];\\r\\n                    for (const row of tbody.children) {\\r\\n                        if (isDomNode(row) && row.tag === \\\"tr\\\") {\\r\\n                            let cellsInCurrentRow = [];\\r\\n                            for (const cell of row.children) {\\r\\n                                if (isDomNode(cell)) {\\r\\n                                    cellsInCurrentRow.push({\\r\\n                                        innerMarkup: this.renderNode(cell),\\r\\n                                        header: cell.tag === \\\"th\\\",\\r\\n                                        align: cell.attributes.align,\\r\\n                                    });\\r\\n                                }\\r\\n                            }\\r\\n                            grid.push(cellsInCurrentRow);\\r\\n                        }\\r\\n                    }\\r\\n                    let columnWidths = [];\\r\\n                    for (let i = 0; i < grid[0].length; i++) {\\r\\n                        columnWidths.push(Math.max(...grid.map(row => { var _a; return ((_a = row[i].innerMarkup) === null || _a === void 0 ? void 0 : _a.length) || 0; })));\\r\\n                    }\\r\\n                    let tableMarkup = [];\\r\\n                    let isFirstRow = true;\\r\\n                    for (const row of grid) {\\r\\n                        let rowMarkup = [];\\r\\n                        for (const column in row) {\\r\\n                            const cell = row[column];\\r\\n                            const innerMarkup = cell.innerMarkup;\\r\\n                            const columnWidth = columnWidths[column];\\r\\n                            if (cell.align === \\\"center\\\") {\\r\\n                                rowMarkup.push(center(innerMarkup, columnWidth));\\r\\n                            }\\r\\n                            else if (cell.align === \\\"right\\\") {\\r\\n                                rowMarkup.push(justifyRight(innerMarkup, columnWidth));\\r\\n                            }\\r\\n                            else {\\r\\n                                rowMarkup.push(justifyLeft(innerMarkup, columnWidth));\\r\\n                            }\\r\\n                        }\\r\\n                        tableMarkup.push(\\\"| \\\" + rowMarkup.join(\\\" | \\\") + \\\" |\\\");\\r\\n                        if (isFirstRow) {\\r\\n                            let rowMarkup = [];\\r\\n                            for (const column in row) {\\r\\n                                const columnWidth = columnWidths[column];\\r\\n                                rowMarkup.push(\\\"-\\\".repeat(columnWidth));\\r\\n                            }\\r\\n                            tableMarkup.push(\\\"|-\\\" + rowMarkup.join(\\\"-|-\\\") + \\\"-|\\\");\\r\\n                            isFirstRow = false;\\r\\n                        }\\r\\n                    }\\r\\n                    return tableMarkup.join(\\\"\\\\n\\\") + \\\"\\\\n\\\\n\\\";\\r\\n                },\\r\\n                \\\"tr\\\": () => null,\\r\\n                \\\"td\\\": (_, im) => im,\\r\\n                \\\"th\\\": (_, im) => im,\\r\\n            };\\r\\n            rules[\\\"div\\\"] = rules[\\\"p\\\"];\\r\\n            rules[\\\"ol\\\"] = rules[\\\"ul\\\"];\\r\\n            return rules;\\r\\n        }\\r\\n        getNodeText(node) {\\r\\n            if (isTextNode(node)) {\\r\\n                return node.textContent || \\\"\\\";\\r\\n            }\\r\\n            else if (isDomNode(node)) {\\r\\n                return node.children.map(child => this.getNodeText(child)).join(\\\" \\\");\\r\\n            }\\r\\n            else {\\r\\n                return null;\\r\\n            }\\r\\n        }\\r\\n        renderNode(node) {\\r\\n            if (isTextNode(node)) {\\r\\n                return node.textContent || \\\"\\\";\\r\\n            }\\r\\n            else if (isDomNode(node) && node.tag in this.rules) {\\r\\n                const innerMarkup = node.children.map(child => this.renderNode(child)).join(\\\"\\\");\\r\\n                return this.executeRule(node.tag, node, innerMarkup);\\r\\n            }\\r\\n            else {\\r\\n                console.log(\\\"Unsupported node type\\\", node);\\r\\n                return null;\\r\\n            }\\r\\n        }\\r\\n        getNextNode(node) {\\r\\n            if (node.parentNode == null) {\\r\\n                return null;\\r\\n            }\\r\\n            let isNext = false;\\r\\n            for (const n of node.parentNode.children) {\\r\\n                if (isNext) {\\r\\n                    return n;\\r\\n                }\\r\\n                else if (n === node) {\\r\\n                    isNext = true;\\r\\n                }\\r\\n            }\\r\\n            return null;\\r\\n        }\\r\\n        executeRule(tag, node, innerMarkup) {\\r\\n            return this.rules[tag](node, innerMarkup);\\r\\n        }\\r\\n    }\\r\\n    const macroImport = \\\"[[$:/core/ui/PageMacros]] [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]] [all[shadows+tiddlers]tag[$:/tags/Macro/View]!has[draft.of]]\\\";\\r\\n    const widgetOptions = {\\r\\n        document: $tw.fakeDocument,\\r\\n        mode: \\\"block\\\",\\r\\n        importVariables: macroImport,\\r\\n        recursionMarker: \\\"yes\\\",\\r\\n    };\\r\\n    function run(filter = defaultFilter, format = defaultFormat) {\\r\\n        if (!filter) {\\r\\n            return \\\"\\\";\\r\\n        }\\r\\n        let output = \\\"\\\";\\r\\n        let renderer = new MarkdownRenderer($tw);\\r\\n        for (const title of $tw.wiki.filterTiddlers(filter)) {\\r\\n            output += renderer.renderTiddler(title);\\r\\n        }\\r\\n        return output;\\r\\n    }\\r\\n    exports.run = run;\\r\\n    ;\\r\\n});\\r\\n\",\"created\":\"20220421104423414\",\"modified\":\"20220513060527168\",\"module-type\":\"macro\",\"tags\":\"\",\"type\":\"application/javascript\"},\"$:/plugins/cdaven/markdown-export/MenuItem\":{\"title\":\"$:/plugins/cdaven/markdown-export/MenuItem\",\"created\":\"20220421104331124\",\"description\":\"Markdown\",\"extension\":\".md\",\"modified\":\"20220513060447770\",\"tags\":\"$:/tags/Exporter\",\"text\":\"<$macrocall $name=\\\"markdown-export\\\" filter=<<exportFilter>> format=\\\"markdown\\\" $output=\\\"text/raw\\\"/>\\n\"},\"$:/plugins/cdaven/markdown-export/readme\":{\"title\":\"$:/plugins/cdaven/markdown-export/readme\",\"created\":\"20220513163340267\",\"modified\":\"20220519051212158\",\"tags\":\"\",\"text\":\"!! What is this?\\n\\nThis is a plugin for ~TiddlyWiki that lets you export tiddlers to Markdown.\\n\\n!! Wait, //which// Markdown?\\n\\nThere are quite a few different Markdown specifications, and I have settled on [[Pandoc Markdown|https://pandoc.org/MANUAL.html#pandocs-markdown]], for two reasons:\\n\\n# Pandoc Markdown is quite capable, with a lot of extensions. All of these extensions will not work in every Markdown renderer, but most will.\\n# [[Pandoc|https://pandoc.org]] itself is a great way to convert from (Pandoc) Markdown to other document formats, such as Word or PDF.\\n\\n!!! Further conversion with Pandoc\\n\\nYou can convert a Markdown file to Word with this simple Pandoc command:\\n\\n```\\npandoc -o output.docx input.md\\n```\\n\\nSimply change \\\".docx\\\" to \\\".html\\\" or \\\".pdf\\\" to convert to other formats, or use [[the --to switch|https://pandoc.org/MANUAL.html#option--to]].\\n\\nYou can also convert this Pandoc Markdown file to CommonMark or GitHub-Flavored Markdown like this:\\n\\n```\\npandoc -o common.md --to commonmark input.md\\npandoc -o github.md --to gfm input.md\\n```\\n\\n!! Some caveats\\n\\nSince ~TiddlyWiki is very expressive -- and has a multitude of plugins -- export plugins such as this probably cannot support all possible variations.\\n\\nConverting to Markdown requires a bunch of compromises, and will therefore be \\\"opinionated\\\". This is how //I// want my Markdown to look.\\n\\n!! How it works\\n\\nThere are two tiddlers involved:\\n\\n* [[$:/plugins/cdaven/markdown-export/MenuItem]] adds an option to the Export Tiddler dropdown menu.\\n* [[$:/plugins/cdaven/markdown-export/markdown-export.js]] defines the Javascript macro `markdown-export`.\\n\\n!! Technical Details\\n\\nThe plugin is written in Typescript, and transpiled to Javascript for modern browsers. It will not work in Internet Explorer, but most modern browsers //should// work.\\n\\n!! Homepage\\n\\nThis plugin's homepage is at https://cdaven.github.io/tiddlywiki/\"}}}"
}